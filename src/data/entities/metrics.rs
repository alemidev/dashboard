//! SeaORM Entity. Generated by sea-orm-codegen 0.10.1

use sea_orm::entity::prelude::*;

use crate::data::FetchError;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "metrics")]
pub struct Model {
	#[sea_orm(primary_key, auto_increment = false)]
	pub id: i64,
	pub name: String,
	pub source_id: i64,
	pub query: String,
	pub color: i32,
	pub position: i32,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
	#[sea_orm(
		belongs_to = "super::sources::Entity",
		from = "Column::SourceId",
		to = "super::sources::Column::Id"
	)]
	Source,

	#[sea_orm(has_many = "super::points::Entity")]
	Point,
}

impl Related<super::sources::Entity> for Entity {
	fn to() -> RelationDef { Relation::Source.def() }
}

impl Related<super::points::Entity> for Entity {
	fn to() -> RelationDef { Relation::Point.def() }
}

impl Related<super::panels::Entity> for Entity {
	fn to() -> RelationDef {
		super::panel_metric::Relation::Panel.def()
	}

	fn via() -> Option<RelationDef> {
		Some(super::panel_metric::Relation::Metric.def().rev())
	}
}

impl ActiveModelBehavior for ActiveModel {}

impl Model {
	pub fn extract(&self, value: &serde_json::Value) -> Result<Option<f64>, FetchError> {
		Ok(jql::walker(value, self.query.as_str())?.as_f64())
	}
}

impl Default for Model {
	fn default() -> Self {
		Model {
			id: 0,
			name: "".into(),
			source_id: 0,
			query: "".into(),
			color: 0,
			position: 0,
		}
	}

}
